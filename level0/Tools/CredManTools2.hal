external function roundmode SetRoundModeD(Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function LongInt MonthDiff(Date,Date);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure CalcSum(val,val,val,val,var val,Integer);
external function LongInt DateDiff(Date,Date);
external outer function val CalcCredManRemVal(record CredManVc); //EBS
external outer function boolean EBS_ShouldItemChangeBal(record CredManVc,string,val); //EBS
external outer procedure CredManVc_CalcVAT(var record CredManVc, string); //EBS
external outer function val FIN_PMT(val, integer, val);
external outer function val FIN_PPMT(val,integer,val,integer);
external outer procedure GetMonthlyVatVector(val,string,var vector val);

global
function val GetIntRate(string type,Date thedat)
begin
  record CredManRateVc CredManRater;
  val res;

  CredManRater.Type = type;
  CredManRater.Date = thedat;
  if (ReadLastMain(CredManRater,2,false)) then begin
    res = CredManRater.IntRate;
  end;
  GetIntRate = res;
  return;
end;

global
function val GetCredManRate(Integer typ,string type,val intrate,Date ondat)
begin
  val res;

  if (typ==0) then begin
    res = intrate;
  end else begin
    res = GetIntRate(type,ondat);
  end;
  GetCredManRate = res;
  return;
end;

global
procedure CalcCredManCurrentPeriod(record CredManVc CredManr,Integer paymentnr,var Date sdp,var Date edp,var Date invd)
begin

  // LogText(0,"paymentnr=" & paymentnr & " sdp=" & sdp & " edp=" & edp & " invd=" & invd);
  if (nonblankdate(CredManr.FirstIntDate)) then begin
    sdp = AddDay(AddMonth(CredManr.FirstIntDate,paymentnr),1);
  end else begin
    sdp = AddDay(AddMonth(CredManr.startDate,paymentnr),1);
  end;
  edp = AddDay(AddMonth(sdp,1),-1);
  if (nonblankdate(CredManr.FirstInvDate)) then begin
    invd = AddMonth(CredManr.FirstInvDate,paymentnr); //  - 1
  end else begin
    invd = AddDay(edp,1);
    invd = edp;
  end;
  // LogText(0,">>> paymentnr=" & paymentnr & " sdp=" & sdp & " edp=" & edp & " invd=" & invd);
  return;
end;

// PlanTypes:
// 0 = Calculcated Interest
// 1 = Issued Interest
// 2 = Issued Instalment
// 3 = Issued Deposit
// 4 = Issued Fee
// 5 = Paid Interest
// 6 = Paid Instalment
// 7 = Paid Deposit
// 8 = Paid Fee
function Integer GetActualPlanType(Integer chargemethod,Integer paidflag,string artcode,string type)
begin
  record CredManSetBlock CMSb;
  record CredManTypeVc CredManTyper; //EBS
  Integer res;
  string 20 installitem; //EBS


  res = 0;
  BlockLoad(CMSb);
 
  //EBS -->
  installitem = CMSb.InstalmentItem;
  CredManTyper.Code = type;
  if ReadFirstMain(CredManTyper,1,true) then begin
    if nonblank(CredManTyper.InstalmentItem) then begin
      installitem = CredManTyper.InstalmentItem;
    end;
  end;
  //EBS <--

  if (artcode==installitem) then begin //EBS edit
    if (paidflag!=1) then begin
      if (chargemethod==1) then begin
        res = 10;
      end else begin
        res = 18;
      end;
    end else begin
      res = 14;
    end;
  end else begin
    if (artcode==CMSb.RateItem) then begin
      if (paidflag!=1) then begin
        if (chargemethod==1) then begin
          res = 9;
        end else begin
          res = 17;
        end;
      end else begin
        res = 13;
      end;
    end else begin
      if (artcode==CMSb.DepositItem) then begin
        if (paidflag!=1) then begin
          if (chargemethod==1) then begin
            res = 11;
          end else begin
            res = 19;
          end;
        end else begin
          res = 15;
        end;
      end else begin
        if (paidflag!=1) then begin
          if (chargemethod==1) then begin
            res = 12;
          end else begin
            res = 20;
          end;
        end else begin
          res = 16;
        end;
      end;
    end;
  end;
  GetActualPlanType = res;
  return;
end;

global
function val GetPlanTypeVal(Integer plantype,val v)
begin
  val res;

  switch (plantype) begin
    case 5: res = -v;
    case 6: res = -v;
    case 7: res = -v;
    case 8: res = -v;
    case 9: res = -v;
    case 10: res = -v;
    case 11: res = -v;
    case 12: res = -v;
    case 13: res = -v;
    case 14: res = -v;
    case 15: res = -v;
    case 16: res = -v;
    otherwise res = v;
  end;
  GetPlanTypeVal = res;
  return;
end;

global
function string 255 GetPlanTypeText(Integer plantype)
begin
  string 255 res;

  switch (plantype) begin
    case 0: res = "Should not happen";
    case 1: res = "Planned Interest";
    case 2: res = "Planned Instalment";
    case 3: res = "Planned Deposit";
    case 4: res = "Planned Fee";
    case 5: res = "Suggested Interest";
    case 6: res = "Suggested Instalment";
    case 7: res = "Suggested Deposit";
    case 8: res = "Suggested Fee";
    case 9: res = "Invoiced Interest";
    case 10: res = "Invoiced Instalment";
    case 11: res = "Invoiced Deposit";
    case 12: res = "Invoiced Fee";
    case 13: res = "Paid Interest";
    case 14: res = "Paid Instalment";
    case 15: res = "Paid Deposit";
    case 16: res = "Paid Fee";
    case 17: res = "Added Interest";
    case 18: res = "Added Instalment";
    case 19: res = "Added Deposit";
    case 20: res = "Added Fee";
  end;
  GetPlanTypeText = res;
  return;
end;

function Boolean AddActualsForToday(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date frdat,Date todat,var record CredManPayPlanVc CredManPayPlanr,var val calcbal,var val acumint,var val realinstpaid,var val realintpaid,var val mfee,var val extrainttopay,Boolean printf)
begin
  record CredManEventVc CredManEventr;
  row CredManEventVc CredManEventrw;
  row CredManPayPlanVc CredManPayPlanrw;
  string 200 keystr;
  Boolean foundf, testf;
  Integer evt,i,rwcnt;
  Boolean res;

  // LogText(0,"frdat=" & frdat & " todat=" & todat);

  res = false;
  keystr = "CredManTransDate:";
  keystr = keystr & CredManr.SerNr;
  CredManEventr.TransDate = frdat;
  foundf = true;
  while (LoopKey(keystr,CredManEventr,1,foundf)) begin
    if (CredManEventr.TransDate>todat) then begin
      foundf = false;
    end;
    //EBS -->
    // Here we should ignore total invoice, because it should not effect deposit invoice or any other invoices
    testf = true;
    if CredManEventr.TransDate == CredManr.startDate and MatRowCnt(CredManEventr)==0 then begin
      testf = false;
    end;
    //EBS <--
    if (foundf) and (testf) then begin
      rwcnt = MatRowCnt(CredManEventr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CredManEventr,i,CredManEventrw);
        evt = GetActualPlanType(CredManr.ChargeMethod,CredManEventr.PaidFlag,CredManEventrw.ArtCode,CredManr.Type);
        // LogText(0,"transdate=" & CredManEventr.TransDate & " type=" & evt & " row=" & i);
        CredManPayPlanrw.ArtCode = "";
        CredManPayPlanrw.TransDate = CredManEventr.TransDate;
        CredManPayPlanrw.PlanType = evt;
        CredManPayPlanrw.Sum = CredManEventrw.Sum;
        CredManPayPlanrw.AcumulatedInt = acumint;
        CredManPayPlanrw.Bal = calcbal;
        CredManPayPlanrw.IssuedNr = CredManEventr.SerNr;
        if (EBS_ShouldItemChangeBal(CredManr,CredManEventrw.ArtCode,CredManEventrw.Sum)) then begin
          switch (evt) begin
            case 0:
              Trace("Should not happen"," case 0");
            case 1:
              // CredManPayPlanrw.Bal = CredManPayPlanrw.Bal + CredManEventrw.Sum; //EBS intereset should not change balance
              CredManPayPlanrw.AcumulatedInt = CredManPayPlanrw.AcumulatedInt - CredManEventrw.Sum;
              if (CredManPayPlanrw.AcumulatedInt<0) then begin
                CredManPayPlanrw.AcumulatedInt = 0;
              end;
            case 2:
  //            if (CredManr.ChargeMethod==1) then begin
                CredManPayPlanrw.Bal = CredManPayPlanrw.Bal - CredManEventrw.Sum;
                realinstpaid = realinstpaid + CredManPayPlanrw.Sum;
  //            end;
            case 3:
  //            CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
            case 4:
              CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
            case 5:
              // CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum; //EBS intereset should not chagne balance
            case 6:
              if (CredManr.ChargeMethod==0) then begin
                CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
                realinstpaid = realinstpaid + CredManPayPlanrw.Sum;
              end;
            case 7:
              CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
            case 8:
              CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
            case 9:
              // CredManPayPlanrw.Bal = CredManPayPlanrw.Bal - CredManEventrw.Sum; //EBS paid interest should not decrease balance
              realintpaid = realintpaid + CredManPayPlanrw.Sum;
              extrainttopay = 0;
            case 10:
    //          if (CredManr.ChargeMethod==1) then begin
                CredManPayPlanrw.Bal = CredManPayPlanrw.Bal - CredManEventrw.Sum;
                realinstpaid = realinstpaid + CredManPayPlanrw.Sum;
    //          end;
            case 11:
              CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
            case 12:
              // CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum; //EBS issued installment sum should not increase balance
            case 13:
              // CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum; //EBS interest should not change balance
            case 14:
              if (CredManr.ChargeMethod==0) then begin
  //              CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
  //              realinstpaid = realinstpaid + CredManPayPlanrw.Sum;
              end;
            case 15:
  //            CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
            case 16:
              CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
            case 17:
              CredManPayPlanrw.Bal = CredManPayPlanrw.Bal + CredManEventrw.Sum;
              CredManPayPlanrw.AcumulatedInt = 0;
            case 18:
  //            if (CredManr.ChargeMethod==1) then begin
                CredManPayPlanrw.Bal = CredManPayPlanrw.Bal - CredManEventrw.Sum;
                realinstpaid = realinstpaid + CredManPayPlanrw.Sum;
  //            end;
            case 19:
  //            CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
            case 20:
              CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
              mfee = mfee + CredManPayPlanrw.Sum;
          end;
        end;
        MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
        acumint = CredManPayPlanrw.AcumulatedInt;
        calcbal = CredManPayPlanrw.Bal;
      end;
      res = true;
    end;
  end;
  AddActualsForToday = res;
  return;
end;

procedure AddSuggestedInstalment(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,val installment,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  record CredManTypeVc CredManTyper; //EBS
  string 20 installitem; //EBS

  //EBS -->
  installitem = CredManSetb.InstalmentItem;
  CredManTyper.Code = CredManr.Type;
  if ReadFirstMain(CredManTyper,1,true) then begin
    if nonblank(CredManTyper.InstalmentItem) then begin
      installitem = CredManTyper.InstalmentItem;
    end;
  end;
  //EBS <--

  v = round(installment,SetRoundModeD(CredManSetb.InstalmentRoundOff));
  if (v!=0) then begin
    CredManPayPlanrw.ArtCode = installitem;//EBS
    CredManPayPlanrw.TransDate = transdate;
    CredManPayPlanrw.PlanType = 6;
    CredManPayPlanrw.Sum = v;
    CredManPayPlanrw.AcumulatedInt = acumint;
    CredManPayPlanrw.Bal = calcbal - v;
    MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
    acumint = CredManPayPlanrw.AcumulatedInt;
    calcbal = CredManPayPlanrw.Bal;
  end;
  return;
end;

procedure AddSuggestedInterest(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,val interest,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;

  v = round(interest,SetRoundModeD(CredManSetb.RateRoundOff));
  if (v!=0) then begin
    CredManPayPlanrw.ArtCode = CredManSetb.RateItem;
    CredManPayPlanrw.TransDate = transdate;
    CredManPayPlanrw.PlanType = 5;
    CredManPayPlanrw.Sum = v;
    CredManPayPlanrw.AcumulatedInt = acumint;
    CredManPayPlanrw.Bal = calcbal;
    // CredManPayPlanrw.Bal = calcbal - v; //EBS interest should not change balance
    MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
    acumint = CredManPayPlanrw.AcumulatedInt;
    calcbal = CredManPayPlanrw.Bal;
  end;
  return;
end;

//EBS -->
procedure AddRemainingValue(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,var val calcbal,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;

  v = CredManr.RemBuyAmt;
  if (v!=0) then begin
    CredManPayPlanrw.ArtCode = CredManSetb.RemBuyItem;
    CredManPayPlanrw.TransDate = transdate;
    CredManPayPlanrw.PlanType = 100;
    CredManPayPlanrw.Sum = v;
    CredManPayPlanrw.AcumulatedInt = blankval;
    CredManPayPlanrw.Bal = calcbal - v;
    MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
    calcbal = CredManPayPlanrw.Bal;
  end;
  return;
end;
//EBS <--

procedure AddCalculatedInterest(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,val interest,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;

  v = interest;
  CredManPayPlanrw.ArtCode = "";
  CredManPayPlanrw.TransDate = transdate;
  CredManPayPlanrw.PlanType = 0;
  CredManPayPlanrw.Sum = v;
  CredManPayPlanrw.AcumulatedInt = acumint + v;
  CredManPayPlanrw.Bal = calcbal;
  MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
  acumint = CredManPayPlanrw.AcumulatedInt;
  calcbal = CredManPayPlanrw.Bal;
  return;
end;

procedure AddIssuedInterest(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,var val extrainttopay,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;

  v = round(acumint,SetRoundModeD(CredManSetb.RateRoundOff));
  if (v>0) then begin
    extrainttopay = v;
    CredManPayPlanrw.ArtCode = CredManSetb.RateItem;
    CredManPayPlanrw.TransDate = transdate;
    CredManPayPlanrw.PlanType = 1;
    CredManPayPlanrw.Sum = v;
    CredManPayPlanrw.AcumulatedInt = 0;
    CredManPayPlanrw.Bal = calcbal; //EBS issued interest should not change balance
    // CredManPayPlanrw.Bal = calcbal + v;
    MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
    acumint = CredManPayPlanrw.AcumulatedInt;
    calcbal = CredManPayPlanrw.Bal;
  end;
  return;
end;

procedure AddPlannedFees(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,var val mfee,var val calcbal,var val acumint,Boolean printf,Boolean inclmonthly)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  row CredManVc CredManrw;
  Integer i,rwcnt;
  val v;
  Boolean addf;

  rwcnt = MatRowCnt(CredManr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManr,i,CredManrw);
    v = CredManrw.Sum - CredManrw.InvoicedSum;
    addf = false;
    if nonblank(CredManSetb.ServFeeItem) and CredManSetb.ServFeeItem==CredManrw.ArtCode and CredManrw.ChargeType==0 then begin
      if (CredManrw.ChargeType==0 and CredManrw.InvoicedOn==-1 and CredManrw.Sum>CredManrw.InvoicedSum) then begin
        addf = true;
        CredManrw.InvoicedSum = CredManrw.Sum;
        MatRowPut(CredManr,i,CredManrw);
      end;
    end else begin
      if blankdate(CredManrw.AddPayDate) or CredManrw.AddPayDate<=transdate or CredManrw.ChargeType!=0 then begin
        if (CredManrw.ChargeType==1 and inclmonthly) then begin
          addf = true;
        end;
        if (CredManrw.ChargeType==0 and CredManrw.InvoicedOn==-1 and CredManrw.Sum>CredManrw.InvoicedSum) then begin
          addf = true;
          CredManrw.InvoicedSum = CredManrw.Sum;
          MatRowPut(CredManr,i,CredManrw);
        end;
      end;
    end;
    // LogText(0,"Adding fee addf=" & addf & " td=" & transdate & " ChargeType=" & CredManrw.ChargeType & " invoiced=" & CredManrw.InvoicedOn & " invoiced=" & CredManrw.InvoicedSum);
    if (addf) then begin
      CredManPayPlanrw.ArtCode = CredManrw.ArtCode;
      CredManPayPlanrw.TransDate = transdate;
      CredManPayPlanrw.PlanType = 4;
      CredManPayPlanrw.Sum = v;
      CredManPayPlanrw.AcumulatedInt = acumint;
      if CredManrw.FeeBalType == 1 then begin
        CredManPayPlanrw.Bal = calcbal + v;
      end;
      // mfee = mfee + v; //EBS fees go seperately no need to add to installment
      MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
      acumint = CredManPayPlanrw.AcumulatedInt;
      calcbal = CredManPayPlanrw.Bal;
    end;
  end;
  return;
end;

procedure AddIssuedDeposit(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;

  v = round(CredManr.DepositSum,SetRoundModeD(CredManSetb.DepositRoundOff));
  CredManPayPlanrw.ArtCode = "";
  CredManPayPlanrw.TransDate = transdate;
  CredManPayPlanrw.PlanType = 3;
  CredManPayPlanrw.Sum = v;
  CredManPayPlanrw.AcumulatedInt = acumint;
  CredManPayPlanrw.Bal = calcbal + v;
  MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
  acumint = CredManPayPlanrw.AcumulatedInt;
  calcbal = CredManPayPlanrw.Bal;
  return;
end;

procedure AddPaidDeposit(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;

  v = round(CredManr.DepositSum,SetRoundModeD(CredManSetb.DepositRoundOff));
  CredManPayPlanrw.ArtCode = CredManSetb.DepositItem;
  CredManPayPlanrw.TransDate = transdate;
  CredManPayPlanrw.PlanType = 7;
  CredManPayPlanrw.Sum = v;
  CredManPayPlanrw.AcumulatedInt = acumint;
  CredManPayPlanrw.Bal = calcbal - v;
  MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
  acumint = CredManPayPlanrw.AcumulatedInt;
  calcbal = CredManPayPlanrw.Bal;
  return;
end;

function Date CredManLastActual(record CredManVc CredManr)
begin
  record CredManEventVc CredManEventr;
  string 200 keystr;
  Date res;

  res = CredManr.startDate;
  keystr = "CredManTransDate:";
  keystr = keystr & CredManr.SerNr;
  CredManEventr.TransDate = AddYear(CredManr.endDate,10);
  if (ReadLastKey(keystr,CredManEventr,1,false)) begin
    res = CredManEventr.TransDate;
  end;
  CredManLastActual = res;
  return;
end;

global
procedure BuildCredManPayPlan(record CredManVc inCredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,Boolean withactuals,Boolean suggestedonsameday)
begin
  record CredManVc CredManr;
  Date thedat;
  Integer i,days;
  Integer months;
  val hundred,twelve,rate,therate,monthtot,calcbal,acumint;
  val sofar,bal_for_interest;
  val instal,inter,opentot,totsum,instalment,interest,extrainttopay;
  val realinstpaid,realintpaid,mfee;
  Date freeuntil,frdat,todat,invdat,lastactual;
  Boolean printf;
  Integer paymentnr,ratedays;
  vector val vatPayments;

  RecordNew(CredManPayPlanr);
  RecordCopy(CredManr,inCredManr);

  if CredManr.VATSum > 0 and nonblank(CredManr.VATAddMonths) then begin
    GetMonthlyVatVector(CredManr.VATSum, CredManr.VATAddMonths, vatPayments);
  end;
  printf = true;
  acumint = 0;
  realinstpaid = 0;
  realintpaid = 0;
  mfee = 0;
  extrainttopay = 0;
  hundred = 100;
  twelve = 12;
  if (nonblankdate(CredManr.FirstIntDate)) then begin
    thedat = AddDay(CredManr.FirstIntDate,1);
  end else begin
    thedat = AddDay(CredManr.startDate,1);
  end;
  months = CredManr.InstalmentMonths;
  days = DateDiff(CredManr.endDate,thedat) + 1;
  if (withactuals) then begin
    lastactual = CredManLastActual(CredManr);
  end else begin
    lastactual = CredManr.startDate;
  end;
  if (CredManr.FreeDays>0) then begin
    freeuntil = AddDay(AddDay(thedat,-1),CredManr.FreeDays);
  end else begin
    freeuntil = AddDay(thedat,-1);
  end;
  totsum = CredManr.InvSum4;
  bal_for_interest = totsum;
  switch (CredManr.InstalmentType) begin
    case 0:
      calcbal = totsum;
    case 1:
      calcbal = totsum;
      instal = Round(totsum / months,SetRoundModeD(CredManSetb.InstalmentRoundOff));
    case 2:
      calcbal = totsum;
      instal = Round(totsum / months,SetRoundModeD(CredManSetb.InstalmentRoundOff));
  end;

  for(i=0;i<=months;i=i+1) begin
    CalcCredManCurrentPeriod(CredManr,i-1,frdat,todat,invdat); //sets dates, frdat, todat and invdat
    therate = GetCredManRate(CredManr.RateType,CredManr.Type,CredManr.IntRate,invdat); //RateType always 0, so therate == CredManr.IntRate
    rate = therate / twelve / hundred;
    // LogText(0,">>>> frdat=" & frdat & " todat=" & todat & " invdat=" & invdat & " i=" & i);
    if (i==0) then begin
      if (withactuals) then begin
        if (AddActualsForToday(CredManr,CredManSetb,CredManr.startDate,thedat,CredManPayPlanr,calcbal,acumint,realinstpaid,realintpaid,mfee,extrainttopay,printf)==false) then begin
          if (CredManr.DepositSum>0) then begin
            AddPaidDeposit(CredManr,CredManSetb,thedat,CredManPayPlanr,calcbal,acumint,printf);
          end;
        end;
      end else begin
        if (CredManr.DepositSum>0) then begin
          AddPaidDeposit(CredManr,CredManSetb,thedat,CredManPayPlanr,calcbal,acumint,printf);
        end;
      end;
      if (CredManr.DepositSum>0) then begin
        bal_for_interest = bal_for_interest - CredManr.DepositSum;
      end;
      AddPlannedFees(CredManr,CredManSetb,thedat,CredManPayPlanr,mfee,calcbal,acumint,printf,false);
    end else begin
      // monthtot = (calcbal) * rate;
      interest = (bal_for_interest) * rate;
      // LogText(0,">>>> interest = " & interest & " calcbal=" & calcbal & " rate=" & rate & " bal_for_interest=" & bal_for_interest);
      AddCalculatedInterest(CredManr,CredManSetb,invdat,CredManPayPlanr,interest,calcbal,acumint,printf);
      AddIssuedInterest(CredManr,CredManSetb,invdat,CredManPayPlanr,extrainttopay,calcbal,acumint,printf);
      if (invdat>lastactual) then begin
        AddPlannedFees(CredManr,CredManSetb,invdat,CredManPayPlanr,mfee,calcbal,acumint,printf,true);
      end;
      if (withactuals) then begin
        if (AddActualsForToday(CredManr,CredManSetb,invdat,invdat,CredManPayPlanr,calcbal,acumint,realinstpaid,realintpaid,mfee,extrainttopay,printf)) then begin
        end;
      end;

      monthtot = FIN_PPMT(rate, CredManr.InstalmentMonths, (CredManr.InvSum4 - CredManr.VATSum - CredManr.RemBuyAmt - CredManr.DepositSum), i);
      // LogText(0,">>>> paymentnr=" & paymentnr & " monthtot=" & monthtot & " thedat=" & thedat);
      monthtot = Round(monthtot, SetRoundModeD(2));
      if (i)==CredManr.InstalmentMonths then begin
        // bal_for_interest will have actual credit agreement remaining amount
        // it could be different from normal monthly amount
        monthtot = bal_for_interest;
      end;
      
      monthtot = monthtot + mfee; //this does not seem very correct as monthly fee should not reduce balance on which interest is calculated
      // interest = acumint + extrainttopay;
      instalment = monthtot;

      if vatPayments[i] > 0 then begin
        instalment = instalment + vatPayments[i];
      end;
      bal_for_interest = bal_for_interest - instalment;

      //Add all remaining balance in the last month installment
      // if (i)==CredManr.InstalmentMonths then begin
      //  instalment = calcbal - CredManr.RemBuyAmt;
      // end;
    end;
    // LogText(0,">>>> i=" & i & " instalment=" & instalment & " interest=" & interest & " invdat=" & invdat & " lastactual=" & lastactual & " monthtot=" & monthtot & " suggestedonsameday=" & suggestedonsameday);
    if ((invdat>lastactual and monthtot>0) or (invdat==lastactual and monthtot>0 and suggestedonsameday)) then begin
      AddSuggestedInstalment(CredManr,CredManSetb,invdat,CredManPayPlanr,instalment,calcbal,acumint,printf);
      AddSuggestedInterest(CredManr,CredManSetb,invdat,CredManPayPlanr,interest,calcbal,acumint,printf);
    end;
  end;

  if (withactuals) then begin
    if (AddActualsForToday(CredManr,CredManSetb,thedat,AddYear(thedat,10),CredManPayPlanr,calcbal,acumint,realinstpaid,realintpaid,mfee,extrainttopay,printf)) then begin
    end;
  end;
  //EBS -->
  if invdat >= CredManr.endDate then begin
    //AddRemainingValue(CredManr,CredManSetb,invdat,CredManPayPlanr,calcbal,printf);CHN::removed 190416
  end;
  //EBS <--
  return;
end;

// Only used with combination: Get Unpaid Instalment Sum
global
function val GetCredManStatus(record CredManVc CredManr,Integer paidflag,Integer type)
begin
  record CredManEventVc CredManEventr;
  row CredManEventVc CredManEventrw;
  Integer rwcnt,i;
  Boolean foundf;
  string 200 keystr;
  val res;

  res = 0;
  CredManEventr.PaidFlag = paidflag;
  keystr = "CredManPaidFlag:";
  keystr = keystr & CredManr.SerNr;
  foundf = true;
  while (LoopKey(keystr,CredManEventr,1,foundf)) begin
    if ((CredManEventr.CredManNr!=CredManr.SerNr) or (CredManEventr.PaidFlag!=paidflag)) then begin
      foundf = false;
    end;
    if (foundf) then begin
      rwcnt = MatRowCnt(CredManEventr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CredManEventr,i,CredManEventrw);
        if (CredManEventrw.ChargeType==type) then begin
          res = res + CredManEventrw.Sum;
        end;
      end;
    end;
  end;
  GetCredManStatus = res;
  return;
end;

function val AddCredManEventToCurBal(Integer paidf,val curbal,Integer typ,val sum)
begin
  val res;

  // decrease balance by issued installment sum
  if typ==2 and paidf==0 then begin
    res = curbal - sum;
    GoTo LAddCredManEventToCurBal;
  end;

  //decrease balance by issued deposit sum
  if typ==0 and paidf!=1 then begin
    res = curbal - sum;
    GoTo LAddCredManEventToCurBal;
  end;

  res = curbal;

  // if (typ!=2) then begin
  //   switch (paidf) begin
  //     case 0: res = curbal + sum;
  //     case 1: res = curbal - sum;
  //     case -1: res = curbal;
  //   end;
  // end else begin
  //   switch (paidf) begin
  //     case 0: res = curbal;
  //     case 1: res = curbal - sum;
  //     case -1: res = curbal;
  //   end;
  // end;
LAddCredManEventToCurBal:;
  AddCredManEventToCurBal = res;
  return;
end;

updating procedure SetAndUpdateCredManBalance(record CredManVc CredManr,var record CredManEventVc thisCredManEventr,Boolean insertthis)
begin
  record CredManEventVc CredManEventr;
  record CredManEventVc oldCredManEventr;
  row CredManEventVc CredManEventrw;
  Boolean foundf,testf,addedf;
  string 200 keystr;
  val curbal;
  Integer i,rwcnt;

  curbal = CredManr.InvSum4;
  addedf = false;
  foundf = true;
  keystr = "CredManTransDate:";
  keystr = keystr & CredManr.SerNr;
  while (LoopKey(keystr,CredManEventr,1,foundf)) begin
    testf = foundf;
    if (insertthis and addedf==false) then begin
      if (thisCredManEventr.TransDate<CredManEventr.TransDate) then begin
        rwcnt = MatRowCnt(thisCredManEventr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(thisCredManEventr,i,CredManEventrw);
          if EBS_ShouldItemChangeBal(CredManr, CredManEventrw.ArtCode, CredManEventrw.Sum) then begin
            curbal = AddCredManEventToCurBal(thisCredManEventr.PaidFlag,curbal,CredManEventrw.ChargeType,CredManEventrw.Sum);
          end;
        end;
        thisCredManEventr.CredManBal = curbal;
        addedf = true;
      end else begin
        if (thisCredManEventr.TransDate==CredManEventr.TransDate) then begin
          if (thisCredManEventr.PaidFlag<CredManEventr.PaidFlag) then begin
            rwcnt = MatRowCnt(thisCredManEventr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(thisCredManEventr,i,CredManEventrw);
              if EBS_ShouldItemChangeBal(CredManr, CredManEventrw.ArtCode, CredManEventrw.Sum) then begin
                curbal = AddCredManEventToCurBal(thisCredManEventr.PaidFlag,curbal,CredManEventrw.ChargeType,CredManEventrw.Sum);
              end;
            end;
            thisCredManEventr.CredManBal = curbal;
            addedf = true;
          end else begin
            if (thisCredManEventr.PaidFlag==CredManEventr.PaidFlag and thisCredManEventr.SerNr<CredManEventr.SerNr) then begin
              rwcnt = MatRowCnt(thisCredManEventr);
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(thisCredManEventr,i,CredManEventrw);
                if EBS_ShouldItemChangeBal(CredManr, CredManEventrw.ArtCode, CredManEventrw.Sum) then begin
                  curbal = AddCredManEventToCurBal(thisCredManEventr.PaidFlag,curbal,CredManEventrw.ChargeType,CredManEventrw.Sum);
                end;
              end;
              thisCredManEventr.CredManBal = curbal;
              addedf = true;
            end;
          end;
        end;
      end;
    end else begin
      if (thisCredManEventr.SerNr==CredManEventr.SerNr) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      rwcnt = MatRowCnt(CredManEventr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CredManEventr,i,CredManEventrw);
        if EBS_ShouldItemChangeBal(CredManr, CredManEventrw.ArtCode, CredManEventrw.Sum) then begin
          curbal = AddCredManEventToCurBal(CredManEventr.PaidFlag,curbal,CredManEventrw.ChargeType,CredManEventrw.Sum);
        end;
      end;
      if (CredManEventr.CredManBal!=curbal) then begin
        RecordCopy(oldCredManEventr,CredManEventr);
        CredManEventr.CredManBal = curbal;
        if (RecordUpdate(oldCredManEventr,CredManEventr,false)==0) then begin
        end;
      end;
    end;
  end;
  if (addedf==false) then begin
    rwcnt = MatRowCnt(thisCredManEventr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(thisCredManEventr,i,CredManEventrw);
      if EBS_ShouldItemChangeBal(CredManr, CredManEventrw.ArtCode, CredManEventrw.Sum) then begin
        curbal = AddCredManEventToCurBal(thisCredManEventr.PaidFlag,curbal,CredManEventrw.ChargeType,CredManEventrw.Sum);
        // StopAlert(878 & " " & curbal & " " & CredManEventrw.ArtCode & " CredManEventrw.Sum=" & CredManEventrw.Sum & " CredManEventrw.ChargeType=" & CredManEventrw.ChargeType);
      end;
    end;
    thisCredManEventr.CredManBal = curbal;
  end;
  return;
end;

updating procedure DeleteCredManEvent(record CredManVc CredManr,record CredManEventVc CredManEventr)
begin
  SetAndUpdateCredManBalance(CredManr,CredManEventr,false);
  RecordDelete(CredManEventr);
  return;
end;

global
updating function Boolean RemoveCredManEvent(record CredManVc CredManr,string filnam,LongInt sernr)
begin
  record CredManEventVc CredManEventr;
  Boolean foundf;
  Boolean res;

  res = false;
  CredManEventr.CredManNr = CredManr.SerNr;
  CredManEventr.FileName = filnam;
  CredManEventr.RecordNr = sernr;
  foundf = true;
  while (LoopKey("FindOriginalRecord",CredManEventr,3,foundf)) begin
    if ((CredManEventr.CredManNr!=CredManr.SerNr) or (CredManEventr.FileName!=filnam) or (CredManEventr.RecordNr!=sernr)) then begin
      foundf = false;
    end;
    if (foundf) then begin
      DeleteCredManEvent(CredManr,CredManEventr);
      StepBack(CredManEventr);
      res = true;
    end;
  end;
  RemoveCredManEvent = res;
  return;
end;

global
procedure CredManEventSumup(var record CredManEventVc CredManEventr)
begin
  row CredManEventVc CredManEventrw;
  Integer i,rwcnt;

  CredManEventr.InvSum = BlankVal;
  CredManEventr.PaidSum = BlankVal;
  rwcnt = MatRowCnt(CredManEventr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManEventr,i,CredManEventrw);
    switch (CredManEventr.PaidFlag) begin
      case -1: CredManEventr.InvSum = CredManEventr.InvSum + CredManEventrw.Sum;
      case 0: CredManEventr.InvSum = CredManEventr.InvSum + CredManEventrw.Sum;
      case 1: CredManEventr.PaidSum = CredManEventr.PaidSum + CredManEventrw.Sum;
    end;
  end;
  CredManEventr.TotSum = CredManEventr.InvSum + CredManEventr.PaidSum;
  return;
end;

global
updating procedure StoreCredManEvent(record CredManVc CredManr,var record CredManEventVc CredManEventr)
begin
  CredManEventr.SerNr = NextSerNr("CredManEventVc",CredManEventr.TransDate,-1,false,"");
  CredManEventSumup(CredManEventr);
  SetAndUpdateCredManBalance(CredManr,CredManEventr,true);
  if (RecordInsert(CredManEventr,true)) then begin
  end;
  return;
end;

global
function Integer GetCurrentMonth(record CredManVc CredManr)
begin
  Date thedat;
  Integer res;

  thedat = CredManr.InvUntil;
  if (nonblankdate(thedat)) then begin
    thedat = AddDay(thedat,1);
  end else begin
    thedat = CredManr.startDate;
  end;
  res = MonthDiff(CredManr.startDate,thedat);
  GetCurrentMonth = res;
  return;
end;

// Must match above calculations.... shame to have two similar functions...
global
procedure CalcCredManSums(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,
                          var val planinst,var val planint,var val planfee,var val plandep,
                          var val suginst,var val sugint,var val sugfee,var val sugdep,
                          var val invdinst,var val invdint,var val invdfee,var val invddep,
                          var val paidinst,var val paidint,var val paidfee,var val paiddep,
                          var val addinst,var val addint,var val addfee,var val adddep,
                          var val lastpaid,var Date lastpaiddate,var val curbal,var val cursuginst,
                          var LongInt contractage)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  LongInt i,rwcnt;
  Date lastevent;
  Boolean addtosug;
  Date bldat;

  planinst = 0; planint = 0; planfee = 0; plandep = 0;
  suginst = 0; sugint = 0; sugfee = 0; sugdep = 0;
  invdinst = 0; invdint = 0; invdfee = 0; invddep = 0;
  paidinst = 0; paidint = 0; paidfee = 0; paiddep = 0;
  addinst = 0; addint = 0; addfee = 0; adddep = 0;
  lastpaid = 0; lastpaiddate = bldat; cursuginst = 0;
  contractage = 0;
  addtosug = true;
  curbal = CredManr.InvSum4 - CredManr.DepositSum;
  lastevent = CredManr.startDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    // LogText(0,"date=" & CredManPayPlanrw.TransDate & " sum=" & CredManPayPlanrw.Sum & " int=" & CredManPayPlanrw.AcumulatedInt & " bal=" & CredManPayPlanrw.Bal);
    switch (CredManPayPlanrw.PlanType) begin
      case 0:
        if (cursuginst>0) then begin
          addtosug = false;
        end;
      case 1: planint = planint + CredManPayPlanrw.Sum;
      case 2: planinst = planinst + CredManPayPlanrw.Sum;
      case 3: plandep = plandep + CredManPayPlanrw.Sum;
      case 4: planfee = planfee + CredManPayPlanrw.Sum;
      case 5:
        sugint = sugint + CredManPayPlanrw.Sum;
        if (addtosug) then begin
          cursuginst = cursuginst + CredManPayPlanrw.Sum;
        end;
      case 6:
        suginst = suginst + CredManPayPlanrw.Sum;
        if (addtosug) then begin
          cursuginst = cursuginst + CredManPayPlanrw.Sum;
        end;
      case 7:
        sugdep = sugdep + CredManPayPlanrw.Sum;
        if (addtosug) then begin
          cursuginst = cursuginst + CredManPayPlanrw.Sum;
        end;
      case 8:
        sugfee = sugfee + CredManPayPlanrw.Sum;
        if (addtosug) then begin
          cursuginst = cursuginst + CredManPayPlanrw.Sum;
        end;
      case 9: invdint = invdint + CredManPayPlanrw.Sum;
      case 10: invdinst = invdinst + CredManPayPlanrw.Sum;
      case 11: invddep = invddep + CredManPayPlanrw.Sum;
      case 12: invdfee = invdfee + CredManPayPlanrw.Sum;
      case 13:
        paidint = paidint + CredManPayPlanrw.Sum;
        lastpaiddate = CredManPayPlanrw.TransDate;
        curbal = curbal - CredManPayPlanrw.Sum;
        if (lastevent!=CredManPayPlanrw.TransDate) then begin
          lastpaid = CredManPayPlanrw.Sum;
        end else begin
          lastpaid = lastpaid + CredManPayPlanrw.Sum;
        end;
      case 14:
        paidinst = paidinst + CredManPayPlanrw.Sum;
        lastpaiddate = CredManPayPlanrw.TransDate;
        curbal = curbal - CredManPayPlanrw.Sum;
        if (lastevent!=CredManPayPlanrw.TransDate) then begin
          lastpaid = CredManPayPlanrw.Sum;
        end else begin
          lastpaid = lastpaid + CredManPayPlanrw.Sum;
        end;
      case 15:
        paiddep = paiddep + CredManPayPlanrw.Sum;
        lastpaiddate = CredManPayPlanrw.TransDate;
        curbal = curbal - CredManPayPlanrw.Sum;
        if (lastevent!=CredManPayPlanrw.TransDate) then begin
          lastpaid = CredManPayPlanrw.Sum;
        end else begin
          lastpaid = lastpaid + CredManPayPlanrw.Sum;
        end;
      case 16:
        paidfee = paidfee + CredManPayPlanrw.Sum;
        lastpaiddate = CredManPayPlanrw.TransDate;
        curbal = curbal - CredManPayPlanrw.Sum;
        if (lastevent!=CredManPayPlanrw.TransDate) then begin
          lastpaid = CredManPayPlanrw.Sum;
        end else begin
          lastpaid = lastpaid + CredManPayPlanrw.Sum;
        end;
      case 17:
        addint = addint + CredManPayPlanrw.Sum;
        curbal = curbal + CredManPayPlanrw.Sum;
        contractage = contractage + 1;
      case 18:
        addinst = addinst + CredManPayPlanrw.Sum;
        curbal = curbal + CredManPayPlanrw.Sum;
      case 19:
        adddep = adddep + CredManPayPlanrw.Sum;
        curbal = curbal + CredManPayPlanrw.Sum;
      case 20:
        addfee = addfee + CredManPayPlanrw.Sum;
        curbal = curbal + CredManPayPlanrw.Sum;
    end;
    if (CredManPayPlanrw.PlanType!=0) then begin
      lastevent = CredManPayPlanrw.TransDate;
    end;
/*
StartFormat(15);
OutString(0,0,"XXX",false);
OutString(100,0,CredManPayPlanrw.TransDate,false);
OutString(200,0,CredManPayPlanrw.PlanType,false);
OutString(300,0,addtosug,false);
OutString(400,0,cursuginst,false);
EndFormat;
*/
  end;
  return;
end;

global
procedure CredManSumup(var record CredManVc CredManr)
begin
  record CredManPayPlanVc CredManPayPlanr;
  record CredManSetBlock CredManSetb;
  row CredManVc CredManrw;
  val planinst,planint,planfee,plandep;
  val suginst,sugint,sugfee,sugdep;
  val invdinst,invdint,invdfee,invddep;
  val paidinst,paidint,paidfee,paiddep;
  val addinst,addint,addfee,adddep;
  val lastpaid,curbal,cursuginst;
  val t, t2;
  Date lastpaiddate;
  LongInt contractage;
  val rate,twelve,hundred;
  Integer i,rwcnt;
  string 10 vatcode;

  hundred = 100;
  twelve = 12;
  BlockLoad(CredManSetb);
  CredManr.endDate = AddMonth(CredManr.FirstInvDate,CredManr.InstalmentMonths - 1);
  //EBS -->
  rate = CredManr.IntRate / twelve / hundred;
  vatcode = CredManSetb.VATCode;
  if nonblank(CredManr.VATCode) then begin
    vatcode = CredManr.VATCode;
  end;
  CredManVc_CalcVAT(CredManr, vatcode);
  CredManr.RemBuyAmt = CalcCredManRemVal(CredManr); //EBS
  t = FIN_PMT(rate, CredManr.InstalmentMonths, (CredManr.InvSum4 - CredManr.VATSum - CredManr.RemBuyAmt - CredManr.DepositSum));
  t = t + CredManr.RemBuyAmt * rate;
  CredManr.MonthlySum = Round(t, SetRoundModeD(2));
  //EBS <--
  BuildCredManPayPlan(CredManr,CredManPayPlanr,CredManSetb,true,false);
  CalcCredManSums(CredManr,CredManPayPlanr,CredManSetb,planinst,planint,planfee,plandep,suginst,sugint,sugfee,sugdep,
                  invdinst,invdint,invdfee,invddep,paidinst,paidint,paidfee,paiddep,addinst,addint,addfee,adddep,
                  lastpaid,lastpaiddate,curbal,cursuginst,contractage);

//  CredManr.TotalInterest = totint;
//  CredManr.TotalSumExclDep = totinst + totint + totfee;
//  CredManr.TotalSum = CredManr.TotalSumExclDep + totdep;
  rate = CredManr.IntRate / twelve / hundred;
  // rate = 1/(1+rate);
  // CredManr.MonthlySum = ((1-rate)*(CredManr.InvSum4 - CredManr.DepositSum - CredManr.RemBuyAmt))/(rate*(1-power(rate,CredManr.InstalmentMonths)));
  rwcnt = MatRowCnt(CredManr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManr,i,CredManrw);
    if (CredManrw.ChargeType==1) then begin
      CredManr.MonthlySum = CredManr.MonthlySum + CredManrw.Sum;
    end;
  end;
  CredManr.MonthlySum = Round(CredManr.MonthlySum,SetRoundModeD(2));
  CredManr.BaseTotalSum = MulRateToBase1(CredManr.CurncyCode,CredManr.TotalSum,CredManr.FrRate,CredManr.ToRateB1,CredManr.ToRateB2,CredManr.BaseRate1,CredManr.BaseRate2,DefaultCurRoundOff);

  return;
end;
